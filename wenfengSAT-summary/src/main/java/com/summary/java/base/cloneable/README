
实现Cloneable

1、基本类型
如果变量是基本类型，则拷贝其值，比如：int、float、long等。
2、String字符串
这个比较特殊，拷贝的是地址，是个引用，但是在修改的时候，它会从字符串池（String Pool）
中重新生成新的字符串，原有的字符串对象保持不变，此处可以认为String是个基本类型。
3、对象
如果变量时一个实例对象，则拷贝地址引用，也就是说此时新拷贝出的对象与原有对象共享该实例变量，
不受访问权限的限制。这在Java中很疯狂，因为它突破了访问权限的定义，一个private修饰的变量，
竟然可以被两个实例对象访问。

只拷贝值、只拷贝地址、只拷贝地址引用

一、浅度克隆
对于要克隆的对象，对于其基本数据类型的属性，复制一份给新产生的对象，对于非基本数据类型的属性，仅仅复制一份引用给新产生的对象，即新产生的对象和原始对象中的非基本数据类型的属性都指向的是同一个对象
1、实现java.lang.Cloneable接口
要clone的类为什么还要实现Cloneable接口呢？Cloneable接口是一个标识接口，不包含任何方法的！这个标识仅仅是针对Object类中clone()方法的，如果clone类没有实现Cloneable接口，并调用了Object的 clone()方法（也就是调用了super.Clone()方法），那么Object的clone()方法就会抛出 CloneNotSupportedException异常。
2、重写java.lang.Object.clone()方法
JDK API的说明文档解释这个方法将返回Object对象的一个拷贝。要说明的有两点：一是拷贝对象返回的是一个新对象，而不是一个引用。二是拷贝对象与用new操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。
观察一下Object类的clone()方法是一个native方法，native方法的效率一般来说都是远高于java中的非native方法。这也解释了为什么要用Object中clone()方法而不是先new一个类，然后把原始对象中的信息赋到新对象中，虽然这也实现了clone功能。Object类中的clone()还是一个protected属性的方法，重写之后要把clone()方法的属性设置为public。
Object类中clone()方法产生的效果是：先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内容。对基本数据类型，这样的操作是没有问题的，但对非基本类型变量，我们知道它们保存的仅仅是对象的引用，这也导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象。



二、深度克隆
在浅度克隆的基础上，对于要克隆的对象中的非基本数据类型的属性对应的类，也实现克隆，这样对于非基本数据类型的属性，复制的不是一份引用，即新产生的对象和原始对象中的非基本数据类型的属性指向的不是同一个对象
要克隆的类和类中所有非基本数据类型的属性对应的类
1、都实现java.lang.Cloneable接口
2、都重写java.lang.Object.clone()方法


三、使用对象序列化和反序列化实现深度克隆
所谓对象序列化就是将对象的状态转换成字节流，以后可以通过这些值再生成相同状态的对象。
对象的序列化还有另一个容易被大家忽略的功能就是对象复制（Clone），Java中通过Clone机制可以复制大部分的对象，但是众所周知，Clone有深度Clone和浅度Clone，如果你的对象非常非常复杂，并且想实现深层 Clone，如果使用序列化，不会超过10行代码就可以解决。
虽然Java的序列化非常简单、强大，但是要用好，还有很多地方需要注意。比如曾经序列化了一个对象，可由于某种原因，该类做了一点点改动，然后重新被编译，那么这时反序列化刚才的对象，将会出现异常。 你可以通过添加serialVersionUID属性来解决这个问题。如果你的类是个单例（Singleton）类，是否允许用户通过序列化机制复制该类，如果不允许你需要谨慎对待该类的实现。
